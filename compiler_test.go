package compiler

import (
	"reflect"
	"testing"

	"github.com/rgehrsitz/rulegopher/pkg/rules"
)

func TestCompileRule(t *testing.T) {
	// Define a test rule with simple conditions
	testRule := rules.Rule{
		Name:     "testRule",
		Priority: 1,
		Conditions: rules.Conditions{
			All: []rules.Condition{
				{Fact: "fact1", Operator: "equal", Value: "value1"},
				{Fact: "fact2", Operator: "greaterThan", Value: 5},
			},
		},
		// Define other fields if necessary
	}

	// Expected bytecode for the test rule
	var expectedBytecode []byte
	// Assuming compileCondition is implemented to handle these conditions
	// and encodeFactName and encodeValue are implemented correctly
	expectedBytecode = append(expectedBytecode, OpLoadFact)
	expectedBytecode = append(expectedBytecode, encodeFactName("fact1")...)
	expectedBytecode = append(expectedBytecode, OpEqual)
	expectedBytecode = append(expectedBytecode, encodeValue("value1")...)

	expectedBytecode = append(expectedBytecode, OpLoadFact)
	expectedBytecode = append(expectedBytecode, encodeFactName("fact2")...)
	expectedBytecode = append(expectedBytecode, OpGreaterThan)
	expectedBytecode = append(expectedBytecode, encodeValue(5)...)

	// Compile the test rule
	bytecode, err := CompileRule(testRule)
	if err != nil {
		t.Fatalf("CompileRule failed: %v", err)
	}

	// Compare the generated bytecode with the expected bytecode
	if !reflect.DeepEqual(bytecode, expectedBytecode) {
		t.Errorf("Expected bytecode %v, got %v", expectedBytecode, bytecode)
	}
}
